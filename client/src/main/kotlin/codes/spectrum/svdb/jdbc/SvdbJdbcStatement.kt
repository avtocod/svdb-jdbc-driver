package codes.spectrum.svdb.jdbc

import codes.spectrum.svdb.ISvdbCursor
import codes.spectrum.svdb.SvdbConnection
import kotlinx.coroutines.runBlocking
import java.sql.*

class SvdbJdbcStatement(
    private val connection: SvdbConnection,
) : Statement {
    private var resultSet: ResultSet? = null
    private var cursor: ISvdbCursor? = null

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun close() {
        cursor?.close()
        resultSet?.close()
    }

    override fun executeQuery(sql: String): ResultSet = runBlocking {
        checkClosed()
        var normalizedSql = sql
        if (!normalizedSql.contains(DRIVER_TAG_MARKER)) {
            normalizedSql += JdbcDriverQuerySuffix
        }
        runWrappingSqlException(DATA_EXCEPTION) {
            cursor = connection.executeQuery(normalizedSql).getOrThrow()
            return@runBlocking SvdbJdbcResultSet(cursor!!)
        }
    }

    private fun checkClosed() {
        if (isClosed) throw SQLException("Statement has been closed", SvdbJdbcState.OBJECT_NOT_IN_STATE.code)
    }


    override fun executeUpdate(sql: String?): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getMaxFieldSize(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun setMaxFieldSize(max: Int) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getMaxRows(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun setMaxRows(max: Int) {
        // TODO("this method called by Dbeaver")
    }

    override fun setEscapeProcessing(enable: Boolean) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getQueryTimeout(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun setQueryTimeout(seconds: Int) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun cancel() {
        checkClosed()
        cursor?.cancel()
    }

    override fun getWarnings(): SQLWarning? {
        return resultSet?.warnings
    }

    override fun clearWarnings() {
        resultSet?.clearWarnings()
    }

    override fun setCursorName(name: String?) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun execute(sql: String): Boolean {
        checkClosed()
        resultSet = executeQuery(sql)
        return true
    }

    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun execute(sql: String?, columnNames: Array<out String>?): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getResultSet(): ResultSet {
        checkClosed()
        return resultSet ?: throw SQLException("result set is not initialized")
    }

    override fun getUpdateCount(): Int {
        return -1
    }

    override fun getMoreResults(): Boolean {
        return false
    }

    override fun getMoreResults(current: Int): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun setFetchDirection(direction: Int) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getFetchDirection(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun setFetchSize(rows: Int) {
        // TODO("this method Called by Dbeaver")
    }

    override fun getFetchSize(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getResultSetConcurrency(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getResultSetType(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun addBatch(sql: String?) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun clearBatch() {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun executeBatch(): IntArray {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getConnection(): Connection {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getGeneratedKeys(): ResultSet {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun getResultSetHoldability(): Int {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun isClosed(): Boolean {
        return resultSet?.isClosed ?: false
    }

    override fun setPoolable(poolable: Boolean) {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun isPoolable(): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun closeOnCompletion() {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    override fun isCloseOnCompletion(): Boolean {
        val methodName = object : Any() {}
            .javaClass
            .enclosingMethod
            .name
        TODO("method name $methodName called")
    }

    companion object {
        private val DRIVER_TAG_MARKER = Regex("\\s+@D\\s+")
    }
}
