package codes.spectrum.svdb.jdbc

import codes.spectrum.svdb.ISvdbCursor
import codes.spectrum.svdb.SvdbConnection
import kotlinx.coroutines.runBlocking
import java.sql.*

class SvdbJdbcStatement(
    private val connection: SvdbConnection,
) : Statement {
    private var resultSet: ResultSet? = null
    private var cursor: ISvdbCursor? = null

    override fun <T : Any?> unwrap(iface: Class<T>?): T = TODO("method name ${retriveFunName()} called")

    override fun isWrapperFor(iface: Class<*>?): Boolean = TODO("method name ${retriveFunName()} called")

    override fun close() {
        cursor?.close()
        resultSet?.close()
    }

    override fun executeQuery(sql: String): ResultSet = runBlocking {
        checkClosed()
        var normalizedSql = sql
        if (!normalizedSql.contains(DRIVER_TAG_MARKER)) {
            normalizedSql += JdbcDriverQuerySuffix
        }
        runWrappingSqlException(DATA_EXCEPTION) {
            cursor = connection.executeQuery(normalizedSql).getOrThrow()
            return@runBlocking SvdbJdbcResultSet(cursor!!)
        }
    }

    private fun checkClosed() {
        if (isClosed) throw SQLException("Statement has been closed", SvdbJdbcState.OBJECT_NOT_IN_STATE.code)
    }


    override fun executeUpdate(sql: String?): Int = TODO("method name ${retriveFunName()} called")

    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int = TODO("method name ${retriveFunName()} called")

    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int = TODO("method name ${retriveFunName()} called")

    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int = TODO("method name ${retriveFunName()} called")

    override fun getMaxFieldSize(): Int = TODO("method name ${retriveFunName()} called")

    override fun setMaxFieldSize(max: Int) = TODO("method name ${retriveFunName()} called")

    override fun getMaxRows(): Int = TODO("method name ${retriveFunName()} called")

    override fun setMaxRows(max: Int) {
        // TODO("this method called by Dbeaver")
    }

    override fun setEscapeProcessing(enable: Boolean) = TODO("method name ${retriveFunName()} called")

    override fun getQueryTimeout(): Int = TODO("method name ${retriveFunName()} called")

    override fun setQueryTimeout(seconds: Int) = TODO("method name ${retriveFunName()} called")

    override fun cancel() {
        checkClosed()
        cursor?.cancel()
    }

    override fun getWarnings(): SQLWarning? {
        return resultSet?.warnings
    }

    override fun clearWarnings() {
        resultSet?.clearWarnings()
    }

    override fun setCursorName(name: String?) = TODO("method name ${retriveFunName()} called")

    override fun execute(sql: String): Boolean {
        checkClosed()
        resultSet = executeQuery(sql)
        return true
    }

    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean = TODO("method name ${retriveFunName()} called")

    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean = TODO("method name ${retriveFunName()} called")

    override fun execute(sql: String?, columnNames: Array<out String>?): Boolean = TODO("method name ${retriveFunName()} called")

    override fun getResultSet(): ResultSet {
        checkClosed()
        return resultSet ?: throw SQLException("result set is not initialized")
    }

    override fun getUpdateCount(): Int {
        return -1
    }

    override fun getMoreResults(): Boolean {
        return false
    }

    override fun getMoreResults(current: Int): Boolean = TODO("method name ${retriveFunName()} called")

    override fun setFetchDirection(direction: Int) = TODO("method name ${retriveFunName()} called")

    override fun getFetchDirection(): Int = TODO("method name ${retriveFunName()} called")

    override fun setFetchSize(rows: Int) {
        // TODO("this method Called by Dbeaver")
    }

    override fun getFetchSize(): Int = TODO("method name ${retriveFunName()} called")

    override fun getResultSetConcurrency(): Int = TODO("method name ${retriveFunName()} called")

    override fun getResultSetType(): Int = TODO("method name ${retriveFunName()} called")

    override fun addBatch(sql: String?) = TODO("method name ${retriveFunName()} called")

    override fun clearBatch() = TODO("method name ${retriveFunName()} called")

    override fun executeBatch(): IntArray = TODO("method name ${retriveFunName()} called")

    override fun getConnection(): Connection = TODO("method name ${retriveFunName()} called")

    override fun getGeneratedKeys(): ResultSet = TODO("method name ${retriveFunName()} called")

    override fun getResultSetHoldability(): Int = TODO("method name ${retriveFunName()} called")

    override fun isClosed(): Boolean {
        return resultSet?.isClosed ?: false
    }

    override fun setPoolable(poolable: Boolean) = TODO("method name ${retriveFunName()} called")

    override fun isPoolable(): Boolean = TODO("method name ${retriveFunName()} called")

    override fun closeOnCompletion() = TODO("method name ${retriveFunName()} called")

    override fun isCloseOnCompletion(): Boolean = TODO("method name ${retriveFunName()} called")

    companion object {
        private val DRIVER_TAG_MARKER = Regex("\\s+@D\\s+")
    }
}

fun retriveFunName(): String {
    return object {}.javaClass.enclosingMethod.name
}

